{
  "ScriptEngineInjection": {
    "desc": "Sanitizer Name: `ScriptEngineInjection`\n\nSummary:\n- The sanitizer in `ScriptEngineInjection.java` detects script engine injections in the `javax.script.ScriptEngine` class.\n- It defines hooks for the `eval` method of `ScriptEngine`:\n  - String variants of `eval` are intercepted with `BEFORE` hooks.\n  - Reader variants of `eval` are intercepted with `REPLACE` hooks.\n- The payload being checked is the string `\"jaz\\\"+\\\"zer\"`.\n- `checkScriptEngineExecuteString` method intercepts string-based `eval` calls and checks script content for the payload:\n  - If payload is present, it reports a `FuzzerSecurityIssueCritical`.\n  - If payload is absent, it guides the fuzzer towards the payload.\n- `checkScriptEngineExecute` intercepts reader-based `eval` calls, converts the content to a string for payload checking:\n  - If payload is present, it reports a `FuzzerSecurityIssueCritical`.\n  - If payload is absent, it guides the fuzzer towards the payload.\n  - Converts the content back to a Reader for method invocation.\n- `readAll` reads all content from a Reader into a String.",
    "alt": [
      "Script Engine Injection"
    ]
  },
  "SqlInjection": {
    "desc": "SqlInjection sanitizer detects SQL injections via two primary methods:\n1. **Methods that take an SQL query as the first argument** (e.g., `java.sql.Statement#execute`).\n2. **Methods that execute already prepared statements without arguments** (e.g., `java.sql.PreparedStatement#execute`).\n\nKey Details:\n- **Injections Check**: It verifies SQL query syntax using JSqlParser. If the syntax is invalid and query execution raises an exception, it reports an SQL injection.\n- **Guidance**: It instructs the fuzzer to inject insecure characters (`'\"\\b\\n\\r\\t\\\\%_`) into SQL queries.\n\n**Exceptions Handling**:\n- Relies on a set of predefined SQL syntax error exceptions (`java.sql.SQLException`, `java.sql.SQLNonTransientException`, `java.sql.SQLSyntaxErrorException`, `org.h2.jdbc.JdbcSQLSyntaxErrorException`, `org.h2.jdbc.JdbcSQLFeatureNotSupportedException`).\n  \n**Triggers Report**: \n- If an invalid query string (based on syntax check) causes one of the predefined exceptions during execution, it reports it as an SQL Injection vulnerability.\n\nMethod `checkSqlExecute` handles the hooks, checks the validity, calls the original method, and handles exception reporting based on the criteria above.",
    "alt": [
      "SQL Injection"
    ]
  },
  "ServerSideRequestForgery": {
    "desc": "**ServerSideRequestForgery.java Sanitizer Summary**\n\n- **Purpose:** Detects and reports Server-Side Request Forgery (SSRF) vulnerabilities by hooking network connection methods and analyzing connection attempts.\n- **Key Mechanisms:**\n  - **Hooks on `connect` Methods:** The sanitizer hooks the `connect` methods of `java.net.SocketImpl` and `java.nio.channels.SocketChannel`, capturing connection attempts made by these classes and other related internal classes (`java.net.Socket`, `java.net.SocksSocketImpl`, `sun.nio.ch.SocketAdaptor`, `jdk.internal.net.http.PlainHttpConnection`).\n  - **Connection Validation:** Each intercepted connection attempt undergoes validation. The hostname and port are extracted from the connection arguments, applicable for `InetSocketAddress`, `InetAddress`, and `String` types.\n  - **Security Check:** The connection host and port are checked against a predicate `connectionPermitted`, which by default excludes all connections to hosts & ports not seen during program initialization. If the connection is not permitted, a medium-severity SSRF issue is reported using `Jazzer.reportFindingFromHook`.\n- **SSRF Reporting:**\n**Custom Network Permissions:** For tests expected to perform legitimate network connections, `com.code_intelligence.jazzer.api.BugDetectors#allowNetworkConnections` can be called to dynamically set permissible connections.\n\n- **Sanitizer Triggering Criteria**:\n  - Cause the program to make any network connection to \"jazzer.example.com\".\n  - If the harness uses `connectionPermitted` calls that would allow \"jazzer.example.com\", instead attempt to make any network connection that would not be permitted.\n  - Indirect network connections also trigger the sanitizer; for example, a SAXParser reading \"jazzer.example.com\" as an XML external entity would also trigger.",
    "alt": [
      "Server Side Request Forgery"
    ]
  },
  "ClojureLangHooks": {
    "desc": "Sanitizer: `ClojureLangHooks.java`\n\nSummary:\n1. **Hook Details**:\n   - Two hooks are defined: `clojureMarkContains` (AFTER) and `clojureMarkedContains` (BEFORE).\n\n2. **String Contains Function Identification (`clojureMarkContains`)**:\n   - Hooked to `clojure.lang.Var.getRawRoot`.\n   - Identifies and memoizes Clojure function objects that check for substrings.\n   - Targets function names: `clojure.string$includes_QMARK_`, `clojure.string$starts_with_QMARK_`, `clojure.string$ends_with_QMARK_`, `clojure.string$index_of_QMARK_`, `clojure.string$last_index_of_QMARK_`.\n   - Stores identified functions in a `ThreadLocal<Set<Object>> stringContainsFuncs`.\n\n3. **Fuzzer Guidance (`clojureMarkedContains`)**:\n   - Hooked to `clojure.lang.IFn.invoke`.\n   - Checks if the invoking object is in `stringContainsFuncs`.\n   - Guides towards string containment if two string arguments are identified: `Jazzer.guideTowardsContainment((String) args[0], (String) args[1], hookId)`.\n\nFor POC: Ensure the POC involves invoking Clojure functions that perform substring checks (`includes_QMARK_`, `starts_with_QMARK_`, etc.) with at least two string arguments to trigger the sanitizer.",
    "alt": []
  },
  "OsCommandInjection": {
    "desc": "Sanitizer Summary for OsCommandInjection.java:\n\n- **Sanitizer Class**: `OsCommandInjection`\n- **Important Static Variable**:\n  - `COMMAND`: The string \"jazze\".\n  \n- **Key Method Annotated for Hooking**:\n  - **Method**: `ProcessImplStartHook`\n    - **Hook Type**: `REPLACE`\n    - **Target Class**: `java.lang.ProcessImpl`\n    - **Target Method**: `start`\n    - **Additional Classes to Hook**: `java.lang.ProcessBuilder`\n\n- **ProcessImplStartHook Method**:\n  - **Arguments**: Takes `MethodHandle handle`, `Object thisObject`, `Object[] args`, and `int hookId`.\n  - **Functionality**:\n        1. **Command Line Argument Check**:\n            - Converts `args[0]` to `String[] cmd_line_args`.\n            - Iterates over `cmd_line_args`.\n            - Checks if any argument equals the string `COMMAND` (\"jazze\").\n            - If a match is found, it reports a critical security issue via `Jazzer.reportFindingFromHook`.\n  \n        2. **Fuzzing Guide**:\n            - Concatenates all command-line arguments into a single string `fuzz_input`.\n            - Calls `Jazzer.guideTowardsContainment(fuzz_input, COMMAND, hookId)` to guide the fuzzer towards the target pattern \"jazze\".\n\n- **Sanitizer Triggering Criteria**:\n  - The sanitizer will be triggered if any part of the program attempts to call out to the system command \"jazze\".\n  - As a secondary triggering condition, if a POV cannot cause the sentinel command \"jazze\" to launch, an attempt to run any command besides \"java\" may cause an IOException to be thrown.",
    "alt": [
      "OS Command Injection"
    ]
  },
  "Utils": {
    "desc": "Sanitizer **`Utils.kt`** functions by leveraging the **`Jazzer`** API to detect and report findings when specific methods are called. Key functionalities include:\n\n1. **`jaz.Zer`** and **`jazzer_honeypot`**:\n   - Constants for identifying the honeypot class and library.\n   \n2. **`Short.toBytes()`**:\n   - Converts a `Short` to a `ByteArray`.\n\n3. **`ByteArray.indexOf(needle: ByteArray): Int`**:\n   - Searches for the `needle` byte array within the larger byte array (`this`). Returns the starting index or -1 if `needle` is not found. It's designed for small arrays.\n\n4. **`guideMarkableInputStreamTowardsEquality(stream: InputStream, target: ByteArray, id: Int)`**:\n   - Reads bytes from the input stream and compares them with a target byte array.\n   - Uses **`Jazzer.guideTowardsEquality`** to steer the fuzzing process towards making the bytes read from the stream equal to the target.\n   - Ensures the stream supports mark/reset operations and uses them to manage the reading/reseeking process.\n\nWhen creating a POC to trigger the `Utils.kt` sanitizer, focus on:\n1. Invoking methods that utilize the `Jazzer.guideTowardsEquality`.\n2. Working with mark-supported `InputStream`s.\n3. Ensuring byte arrays (possibly through `indexOf`) match specific patterns or transformations that the sanitizer monitors.\n\n",
    "alt": []
  },
  "ExpressionLanguageInjection": {
    "desc": "Sanitizer: **ExpressionLanguageInjection**\n- **Purpose**: Detects injectable inputs to an expression language interpreter which may lead to remote code execution.\n\n- **Key Attack Payload**: \n  ```kotlin\n  private const val EXPRESSION_LANGUAGE_ATTACK = \"\\${Byte.class.forName(\\\"jaz.Zer\\\").getMethod(\\\"el\\\").invoke(null)}\"\n  ```\n\n- **Hooked Methods**:\n  - `javax.el.ExpressionFactory.createValueExpression`\n  - `javax.el.ExpressionFactory.createMethodExpression`\n  - `jakarta.el.ExpressionFactory.createValueExpression`\n  - `jakarta.el.ExpressionFactory.createMethodExpression`\n  - `javax.validation.ConstraintValidatorContext.buildConstraintViolationWithTemplate`\n\n- **Hook Type**: `BEFORE`\n\n- **Hook Logic**:\n  - For `ExpressionFactory` methods, they must have at least 3 arguments; the second argument must be a `String`.\n  - For `buildConstraintViolationWithTemplate`, the method must have exactly 1 argument which is a `String`.\nTherefore, if you can inject arbitrary expression code, use the payload \"\\${Byte.class.forName(\\\"jaz.Zer\\\").getMethod(\\\"el\\\").invoke(null)}\" to trigger the sanitizer.",
    "alt": []
  },
  "Deserialization": {
    "desc": "Sanitizer: Deserialization.kt\n\n### Summary\n\n1. **Headers**: The sanitizer detects unsafe deserialization leading to attacker-controlled method calls, particularly `Object.finalize`.\n2. **Object Input Stream Initialization Hooks**:\n    - **Before Hook**: Ensures the input stream passed to `ObjectInputStream` constructor is markable. Replaces non-markable streams with a `BufferedInputStream`. Guides the fuzzer towards generating a valid header for `ObjectInputStream`.\n    - **After Hook**: Memoizes the input stream used in the `ObjectInputStream` instance in a `ThreadLocal` `WeakHashMap`.\n3. **Serialized Honeypot**:\n    - Contains serialized instance of `jaz.Zer`, created by serializing `jaz.Ter` and modifying the class name.\n    - Ensures size fits within 64 bytes.\n4. **Read Object Hooks**:\n    - Hooks for `readObject`, `readObjectOverride`, and `readUnshared` methods.\n    - Guides the fuzzer towards producing a valid serialized instance of the honeypot class (`jaz.Zer`).\n\n### Key Points\n\n- **Classes and Methods**:\n  - Hooks on `ObjectInputStream` constructor and read methods to insert custom logic.\n- **InputStream Handling**:\n  - Ensures markable input stream in `ObjectInputStream` constructor.\n  - Uses `ThreadLocal<WeakHashMap>` to track `ObjectInputStream` to `InputStream` mappings.\n- **Fuzzing Guidance**:\n  - Aims to produce valid `ObjectInputStream` headers and valid serialized instances of the honeypot class during fuzzing.\n\n### Guide for PoC\n\n- Ensure `ObjectInputStream` is initialized with a markable `InputStream`.\n- Trigger hooks by invoking `ObjectInputStream` constructor and read methods (`readObject`, `readObjectOverride`, `readUnshared`).\n- Focus on generating and deserializing data corresponding to `jaz.Zer` or valid stream headers.\n The following base64 blob is a valid serialized instance of the jaz.Zer class to trigger this sanitizer `rO0ABXNyAAdqYXouWmVyAAAAAAAAACoCAAFCAAlzYW5pdGl6ZXJ4cAA=`",
    "alt": [
      "Remote Code Execution"
    ]
  },
  "FilePathTraversal": {
    "desc": "Sanitizer: FilePathTraversal\n\n### Summary\n\nConsiders the program susceptible to path injection if any attempt to read a magic file path occurs.\nThe magic file is set in the harness by `System.setProperty(\"jazzer.file_path_traversal_target\", ...)`, or defaults to `../jazzer-traversal`.\n\nThe sanitizer triggers on:\n  - Basically any `java.nio.file.Path` argument to any `java.nio.file.Files` method\n  - Initialization of any file-opening class, e.g. `java.io.FileReader`, `java.io.FileWriter`, `java.io.FileInputStream`, `java.io.FileOutputStream`\n  - Any `open` method of a file-reading class, e.g. `java.nio.channels.FileChannel`\n  - Utilities that cause files to be read, such as `java.util.Scanner` or `java.nio.file.spi.FileTypeDetector.probeContentType`\n  - The sanitizer will also trigger on indirect calls to these methods, e.g. hidden within libraries.\n\nWatch out for any `java.io.File`, `java.nio.file.Path`, `java.net.URI` or similar object that can be created or manipulated to point to `../jazzer-traversal`.\nIf it looks like that path might actually be accessed later, this will trigger the sanitizer.",
    "alt": []
  },
  "LdapInjection": {
    "desc": "LdapInjection sanitizer targets LDAP Distinguished Name (DN) and search filter injections in Java applications. It is designed to test if untrusted input is properly escaped, ensuring queries remain valid. \n\nKey Points:\n1. **Characters to Escape**:\n   - DN: \"\\\\+<>,;\\\"=\"\n   - Search Filter: \"*()\\\\\\u0000\"\n\n2. **Hooked Methods**:\n   - `javax.naming.directory.DirContext`'s `search` methods, particularly those accepting `String` parameters susceptible to injection.\n\n3. **Fuzzer Guidance**:\n   - Uses `Jazzer.guideTowardsEquality` to steer fuzzing towards injecting insecure characters into these methods' arguments.\n\n4. **Exception Handling**:\n   - Catches exceptions during method execution.\n   - Reports findings via `Jazzer.reportFindingFromHook` when exceptions like `InvalidSearchFilterException` or `NamingException` occur, indicating a successful injection.\n\nPotential triggers need to cause exceptions by injecting unescaped characters in `DirContext` search methods. Ensure inputs include characters defined for DN and search filter to validate the sanitizer.",
    "alt": [
      "LDAP Injection"
    ]
  },
  "NamingContextLookup": {
    "desc": "**Sanitizer: NamingContextLookup**\n\n**Summary:**\n- **Sanitizer Triggers:**\n  - Monitors calls to `javax.naming.Context` methods `lookup` and `lookupLink`.\n  - These methods are hooked using `MethodHook` of type `REPLACE`.\n  - The hook identifies URLs that start with `ldap://g.co/` and `rmi://g.co/`.\n- **Function Hook Details:**\n  - The `lookupHook` method is used as the hook.\n  - `args[0]` is cast to a `String`, representing the URL being looked up.\n  - If URL starts with `ldap://g.co/` or `rmi://g.co/`, a security issue is reported:\n    - **Issue Type:** `FuzzerSecurityIssueCritical`\n    - **Description:** Remote JNDI Lookup can lead to remote code execution or information exfiltration.\n  - The `Jazzer.guideTowardsEquality` function is used to guide fuzzing towards these URLs.\n  - `CommunicationException` is thrown to simulate endpoint connection failure, preventing accidental remote code execution during fuzzing.\n\n**Important Constants:**\n- `LDAP_MARKER = \"ldap://g.co/\"`\n- `RMI_MARKER = \"rmi://g.co/\"`\n\nThis sanitizer focuses on identifying and reporting potential vulnerabilities from remote JNDI lookups using specific markers in the URLs.",
    "alt": [
      "Remote JNDI Lookup"
    ]
  },
  "ReflectiveCall": {
    "desc": "ReflectiveCall.kt sanitizer detects unsafe class loading and library loading by hooking into specific Java methods related to class and library loading. It uses the Jazzer framework to guide fuzzers:\n\n1. **Class Loading Hooks**:\n   - Hooks `Class.forName(String)`, `Class.forName(String, boolean, ClassLoader)`, `ClassLoader.loadClass(String)`, `ClassLoader.loadClass(String, boolean)`, and similar methods involving modules.\n   - Before these methods are called (`HookType.BEFORE`), the hook checks the class name argument.\n   - Uses `Jazzer.guideTowardsEquality` to direct the fuzzer towards loading a specific honeypot class `jaz.Zer`.\n\n2. **Library Loading Hooks**:\n   - Hooks `Runtime.load`, `Runtime.loadLibrary`, `System.load`, `System.loadLibrary`, `System.mapLibraryName`, and `ClassLoader.findLibrary`.\n   - Before these methods are called (`HookType.BEFORE`), the hook checks the library name argument.\n   - If the library name matches `\"jazzer_honeypot\"`, it reports a high security issue (`FuzzerSecurityIssueHigh(\"load arbitrary library\")`) using `Jazzer.reportFindingFromHook`.\n   - Also uses `Jazzer.guideTowardsEquality` to direct the fuzzer towards loading a specific library (`jazzer_honeypot`).\n\nTo trigger the sanitizers, manipulate inputs to the targeted methods (`Class.forName`, `ClassLoader.loadClass`, `Runtime.load`, etc.) to match the honeypot class or library names.\n The following base64 blob is a valid serialized instance of the jaz.Zer class to trigger this sanitizer `rO0ABXNyAAdqYXouWmVyAAAAAAAAACoCAAFCAAlzYW5pdGl6ZXJ4cAA=`",
    "alt": [
      "load arbitrary library"
    ]
  },
  "XPathInjection": {
    "desc": "Sanitizer: XPathInjection.kt\n\n**Function:**\nDetects XPath injections by ensuring untrusted input is properly escaped to avoid injection.\n\n**Key Components:**\n1. **Characters to Escape:**\n   - `CHARACTERS_TO_ESCAPE`: `\"'\\\"` (single and double quotes)\n\n2. **Monitored Exceptions:**\n   - `XPATH_SYNTAX_ERROR_EXCEPTIONS`: `\"javax.xml.transform.TransformerException\"`\n\n3. **Hooked Methods:**\n   - `javax.xml.xpath.XPath.compile`\n   - `javax.xml.xpath.XPath.evaluate`\n   - `javax.xml.xpath.XPath.evaluateExpression`\n\n4. **Sanitizer Logic:**\n   - The sanitizer guides the fuzzer to inject insecure characters (`CHARACTERS_TO_ESCAPE`) via `Jazzer.guideTowardsContainment()`.\n   - It tries to invoke the original method using `method.invokeWithArguments()`.\n   - If an `XPathExpressionException` is thrown, it checks whether the innermost cause is a `TransformerException` to confirm injection.\n   - If confirmed, it reports a high-severity issue (`FuzzerSecurityIssueHigh`) using `Jazzer.reportFindingFromHook()`.\n\nIn the POC, inject the specified insecure characters (`'` and `\"`) into the monitored XPath methods to trigger the sanitizer. If the input is not correctly escaped, it should raise `XPathExpressionException` and report the issue if the cause is `TransformerException`.",
    "alt": [
      "XPath Injection"
    ]
  },
  "RegexInjection": {
    "desc": "**Sanitizer: RegexInjection**\n\n- **Purpose**: Detects and reports potential regular expression injection vulnerabilities in Java programs.\n\n- **Key Concepts**:\n  - **Regex Injection**: Unescaped inputs in regex patterns can cause excessive CPU usage or memory allocation.\n  - **CANON_EQ Flag**: Special flag in `Pattern.compile` that significantly increases array size with Unicode combining marks.\n\n- **Sensitive Patterns**:\n  - **CANON_EQ Exploit**: Sequences like three consecutive combining marks (e.g., `\"\\u0300\\u0300\\u0300\"`).\n  - **Pattern Syntax Exception Inducer**: A sequence to break out of regex (e.g., `\"\\\\E]\\\\E]]]]]]\"`).\n\n- **Triggered Methods**:\n  - **java.util.regex.Pattern.compile(String, int)**\n  - **java.util.regex.Pattern.compile(String)**\n  - **java.util.regex.Pattern.matches(String, CharSequence)**\n  - **java.lang.String.matches(String)**\n  - **java.lang.String.replaceAll(String, String)**\n  - **java.lang.String.replaceFirst(String, String)**\n  - **java.lang.String.split(String)**\n  - **java.lang.String.split(String, int)**\n\n- **Detection Mechanism**:\n  - **Out-of-Memory Exploits**: Report if `\"CANON_EQ\"` flag and exploit pattern found.\n  - **Pattern Syntax Exception**: Focuses fuzzer to guide towards syntax exception causing patterns.\n\n- **Reporting**:\n  - **Low Security Issue for CANON_EQ**: Indicates large memory allocations with `CANON_EQ` flag.\n  - **Low Security Issue for General Injection**: Indicates unescaped untrusted input.\n\n- **Error Handling**:\n  - Reporting pattern syntax errors, unless they start with \"Stack overflow during pattern compilation\". \n\nWhen creating POCs, make sure they involve invoking regex manipulative methods (`compile`, `matches`, `replaceAll`, `replaceFirst`, `split`) with patterns containing untrusted input or targeted sequences for CANON_EQ vulnerabilities.",
    "alt": [
      "Regular Expression Injection"
    ]
  },
  "BusinessLogic": {
    "alt": ["business logic"],
    "desc": "BusinessLogic is not a specific sanitizer, but indicates that we found code that looked suspicious. We can still potentially trigger a Jazzer sanitizer or raise an exception by excercising faults in the code logic.\n\nPOCs should attempt to abuse incorrect logic in the code, such as bypassing a faulty authorization check or raising an uncaught exception."
  }
}