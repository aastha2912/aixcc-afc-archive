{
  "nginx-asc": {
    "0": {
      "function": "ngx_http_script_regex_end_code",
      "file": "nginx/src/http/ngx_http_script.c",
      "description": "The length\u2010check branch assigns e->ip = ngx_http_script_exit but does not return, so the final e->ip += sizeof(\u2026) offsets the exit pointer into arbitrary memory. Subsequent dereference in ngx_http_script_run leads to invalid code execution and crashes.",
      "conditions": "Invoke a rewrite regex (non-redirect, no-args path) that produces a rewritten URI longer than 2000 bytes. The check is hit, setting e->ip wrongly, and the script engine will then crash."
    },
    "11": {
      "function": "ngx_http_auth_basic_user",
      "file": "nginx/src/http/ngx_http_core_module.c",
      "description": "Base64 decode writes past the 16-byte pool buffer because auth.len is fixed to NGX_HTTP_AUTH_MAX without bounds checks in ngx_decode_base64_internal.",
      "conditions": "Send an HTTP Authorization: Basic header with Base64 payload decoding to more than 16 bytes (e.g., 24 'A's yields 18 decoded bytes)."
    },
    "21": {
      "function": "ngx_http_userid_get_uid",
      "file": "nginx/src/http/modules/ngx_http_userid_filter_module.c",
      "description": "Out-of-bounds write to the fixed 16-byte buffer ctx->uid_got due to decoding more than 22 bytes of Base64 data without length enforcement.",
      "conditions": "Send a Cookie header with the configured cookie name (default \u201cuserid\u201d) and a valid Base64 value \u226524 characters long (e.g., 24, 28, 32\u2026), causing ngx_decode_base64 to write past the 16-byte uid_got buffer."
    },
    "34": {
      "function": "ngx_black_list_remove",
      "file": "nginx/src/core/ngx_cycle.c",
      "description": "\n    Removing the head node in ngx_black_list_remove frees it but does not update cycle->black_list, leaving a dangling pointer. On the next connection, ngx_is_ip_banned dereferences the freed node\u2019s IP field, causing a crash (use-after-free).\n  ",
      "conditions": "\n    1) Send HTTP request with header \"Black-List: 1.2.3.4\" to insert a single entry."
    },
    "44": {
      "function": "ngx_http_get_last_ip_variable",
      "file": "nginx/src/http/ngx_http_variables.c",
      "description": "Dereferences last_ip when connection_history is NULL, causing a NULL\u2010pointer crash.",
      "conditions": "Any HTTP request in a configuration that references the $last_ip variable. The history list is never set up, so r->connection_history is NULL."
    },
    "74": {
      "function": "ngx_sendfile_r",
      "file": "nginx/src/os/unix/ngx_linux_sendfile_chain.c",
      "description": "Heap\u2010based buffer overflow in ngx_sendfile_r(): allocates NGX_SENDFILE_R_MAXSIZE (100) bytes for 'rev' but writes 'size' bytes into it based on the requested range.",
      "conditions": "Trigger via an HTTP Range header using the new 'r' modifier (e.g. `bytes=-r,0-200`) so that file->rev is set, and request length >100 to overflow the 100-byte buffer."
    },
    "88": {
      "function": "ngx_mail_pop3_user",
      "file": "nginx/src/mail/ngx_mail_pop3_handler.c",
      "description": "Heap\u2010based buffer overflow by copying s->login.len bytes into a 100\u2010byte palloc when handling the USER command without checking that len \u2264100.",
      "conditions": "Send a POP3 USER command with a username longer than 100 bytes (e.g., \u201cUSER \u201d + 200 \u2018A\u2019s + \u201c\\r\n\u201d)."
    },
    "101": {
      "function": "ngx_mail_smtp_noop",
      "file": "nginx/src/mail/ngx_mail_smtp_handler.c",
      "description": "On NOOP with more than 10 arguments, the handler closes the connection early then returns NGX_ERROR; the caller then invokes ngx_mail_session_internal_server_error, which dereferences the freed connection (use-after-free).",
      "conditions": "Establish an SMTP session, send a NOOP command with over 10 arguments (e.g. \"NOOP a a a a a a a a a a a\\r\n\"), triggering the error branch."
    },
    "111": {
      "function": "ngx_http_process_prefer",
      "file": "nginx/src/http/ngx_http_request.c",
      "description": "On duplicate Prefer headers, the previous header struct is freed but the pointer is left non\u2010NULL. A third Prefer header causes a second free on the same pointer (double\u2010free), and a second header alone leads to use\u2010after\u2010free when that pointer is later dereferenced in the header filter.",
      "conditions": "Send at least three `Prefer: ...` headers in an HTTP/1.1 request to trigger the double\u2010free under sanitizers. (Second header primes the dangling pointer, third fires the second free.)"
    },
    "122": {
      "function": "ngx_init_cycle",
      "file": "nginx/src/core/ngx_cycle.c",
      "description": "if !ccf->remote_admin, host_specs is freed but the pointer is left dangling, leading to a UAF during access in the /host_specs endpoint.",
      "conditions": "Access the /host_specs endpoint when remote_admin is disabled."
    },
    "152": {
      "function": "ngx_http_trace_handler",
      "file": "nginx/src/http/ngx_http_request.c",
      "description": "Heap buffer overflow due to writing request line and headers into a fixed-size (200 byte) heap buffer without bounds checking. An attacker can trigger this by sending a TRACE request with a long request line or many/large headers, causing a crash or potentially arbitrary code execution.",
      "conditions": "Send an HTTP TRACE request with a long request line or large/many headers, such that the total length exceeds 200 bytes. TRACE must be enabled via configuration."
    },
    "164": {
      "function": "ngx_http_validate_from",
      "file": "nginx/src/http/ngx_http_request.c",
      "description": "Off\u2010by\u2010one buffer overflow: allocates `from->len` bytes then writes a terminating '\\\\0' at offset `len`, one byte past the allocated buffer.",
      "conditions": "Any valid From header (e.g. \\\"From: user@example.com\\\") passes validation to the final state and triggers the extra NUL write immediately beyond the allocated pool block."
    },
    "171": {
      "function": "ngx_mail_pop3_pass",
      "file": "nginx/src/mail/ngx_mail_pop3_handler.c",
      "description": "Writes the username into new_auth_log->username.data without ever allocating or initializing that pointer, causing arbitrary writes into memory.",
      "conditions": "Issue \u201cLOGS\u201d to set c->auth_log (allocating uninitialized struct), then \u201cUSER foo\u201d followed by \u201cPASS bar\u201d to trigger the unsafe copy loop."
    },
    "183": {
      "function": "ngx_http_set_browser_cookie",
      "file": "nginx/src/http/ngx_http_core_module.c",
      "description": "Heap buffer overflow when constructing the \u201cBrowser-Cookie\u201d header: the code allocates NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3 bytes but calls ngx_sprintf with format \"\\\"%xT-%xO\\\":%s\", so any non-empty Cookie string (and even the colon) overruns the buffer.",
      "conditions": "Request must trigger static_handler (e.g., GET on existing file), have headers_in.safari == 1 (Safari User-Agent passed and no Opera/MSIE/Chrome override), and include a Cookie header. Any Cookie length > (allocated_size - numeric_and_literal_size) will overflow."
    }
  },
  "tomcat-theori": {
    "38": {
      "function": "validate",
      "file": "tomcat/java/org/apache/catalina/webresources/StandardRoot.java",
      "description": "Decoding after normalization allows percent-encoded \u201c..\u201d and \u201c/\u201d sequences (e.g. \u201c%2e%2e\u201d and \u201c%2f\u201d) to be reintroduced, bypassing RequestUtil.normalize\u2019s removal of \u201c../\u201d segments and leading to directory traversal.",
      "conditions": "Send a resource path containing percent-encoded traversal segments, for example \"/WEB-INF/%2e%2e/%2e%2e/conf/server.xml\". After normalization and decoding, this becomes \"/WEB-INF/../../conf/server.xml\", allowing access outside the webapp root."
    },
    "39": {
      "function": "checkCredentials",
      "file": "tomcat/java/org/apache/catalina/realm/JNDIRealm.java",
      "description": "Backdoor authentication bypass: any password whose SHA-256 digest starts with byte sequence 0x13,0x33,0x37 is accepted.",
      "conditions": "Supply a credentials string whose SHA-256 hash\u2019s first three bytes equal 0x13, 0x33, 0x37. Such a string can be found by brute-forcing ~2^24 possibilities offline."
    },
    "40": {
      "function": "compareEntityTag",
      "file": "tomcat/java/org/apache/tomcat/util/http/parser/EntityTag.java",
      "description": "Unsanitized execution of system commands from ETag header values enclosed in backticks. The code takes the inner payload of a quoted backtick-enclosed value and passes it directly to Runtime.getRuntime().exec(), leading to arbitrary command execution on the server.",
      "conditions": "Include an ETag header (e.g., If-Match or If-None-Match) with a quoted backtick-enclosed string such as \"`id`\" (including the surrounding quotes) to trigger Runtime.exec(\"id\")."
    }
  },
  "curl-theori": {
    "48": {
      "function": "parseurl",
      "file": "curl/lib/urlapi.c",
      "description": "\n    The patch adds a block:\n      if(checkprefix(\"__backdoor\", ptr)) { free(url); }\n    inside parseurl\u2019s handling of file:// URLs. This frees the url pointer (not owned by parseurl) and then continues execution, leading to an invalid free and subsequent use-after-free of url/path.\n  ",
      "conditions": "\n    Provide a URL such as \u201cfile://__backdoor/anything\u201d. When parseurl processes the authority component \u201c__backdoor\u2026\u201d, it matches the prefix, frees url, and then later dereferences the freed memory.\n  "
    },
    "49": {
      "function": "setopt_int",
      "file": "curl/lib/setopt.c",
      "description": "Signed integer overflow vulnerability in HTTP version validation. When an attacker passes INT_MAX (2147483647) as the HTTP version option, the added `arg += 1` line causes signed integer overflow, leading to undefined behavior that could potentially bypass validation checks.",
      "conditions": "An attacker must be able to call curl option setting functions with CURLOPT_HTTP_VERSION and pass INT_MAX as the value. The vulnerability manifests when the value doesn't match any of the accepted HTTP version constants and reaches the default case."
    }
  },
  "example-libpng-theori": {
    "37": {
      "function": "png_handle_iCCP",
      "file": "libpng/pngrutil.c",
      "description": "Out-of-bounds read of the keyword buffer due to incorrect loop limits after switching to a wide-character array; the code uses byte-based bounds on a 2-byte element buffer.",
      "conditions": "Send a PNG with an iCCP chunk whose keyword portion has \u226582 non-zero bytes (no null terminator in the first 82 bytes), so `read_length`=82 and the while-loop reads past the 41-element buffer. Under sanitizers, this OOB read crashes."
    },
    "38": {
      "function": "png_set_text_2",
      "file": "libpng/pngset.c",
      "description": "Heap buffer overflow and missing null terminator when rewriting the key \"desc\" to \"Description\". The code allocates based on the original key length (4) but copies 11 bytes.",
      "conditions": "A PNG with a tEXt (or zTXt/iTXt) chunk whose keyword is exactly \"desc\". The overflow is triggered even if the text is empty or small."
    },
    "39": {
      "function": "png_handle_eXIf",
      "file": "libpng/pngrutil.c",
      "description": "When an eXIf chunk of length 1337 is parsed, png_handle_eXIf calls png_set_eXIf_2 which assigns info_ptr->exif to the freshly malloc\u2019d buffer and sets it for freeing, then immediately frees that same buffer. Later, png_free_data will free info_ptr->exif again, causing a double\u2010free (and potential use-after-free).",
      "conditions": "A PNG input containing an eXIf chunk with length exactly 1337, valid two\u2010byte byte-order header (both \u2018M\u2019 or \u2018I\u2019), and correct CRC so that png_crc_finish returns 0."
    }
  },
  "zstd-theori": {
    "47": {
      "function": "ZSTD_decompressBlock_internal",
      "file": "zstd/lib/decompress/zstd_decompress_block.c",
      "description": "Conditional free(ip) frees the input buffer pointer passed in as `src`, which was not allocated by the library, causing invalid free and use-after-free.",
      "conditions": "Call `ZSTD_decompressBlock` (or frame-based `ZSTD_decompressDCtx`) with `srcSize >= 7` and bytes `src[4]=='A'(0x41)`, `src[5]=='B'(0x42)`, `src[6]=='C'(0x43)` to trigger the free of `ip`."
    },
    "48": {
      "function": "ZSTD_compressSequences_internal",
      "file": "zstd/lib/compress/zstd_compress.c",
      "description": "Removal of `RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall, \u2026)` allows out-of-bounds writes when dstCapacity < ZSTD_blockHeaderSize.",
      "conditions": "Call ZSTD_compress (or ZSTD_compressSequences) with dstCapacity &lt; 3 and srcSize &ge; 7 bytes, causing blockSize \u2265 7, entering the compress path at line ~6163 and invoking ZSTD_entropyCompressSeqStore at an out-of-range pointer (op+3) with underflowed capacity."
    },
    "49": {
      "function": "ZSTD_compressContinue_internal",
      "file": "zstd/lib/compress/zstd_compress.c",
      "description": "Use-after-free: `cctx` is freed inside the function but then still used for window overflow correction, block compression, and size accounting.",
      "conditions": "Call ZSTD_compressContinue_internal with cctx->appliedParams.ldmParams.enableLdm set to ZSTD_ps_enable (LDM enabled); immediately triggers free(cctx) and subsequent dereferences of `cctx`."
    }
  },
  "afc-zookeeper": {
    "40": {
      "function": "verifyIPv6",
      "file": "zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/util/MessageTracker.java",
      "description": "\n    The helper countExtraColons called by verifyIPv6 uses serverAddr.indexOf(':') without changing its start position, so when serverAddr contains \u22658 colons, the loop never terminates.\n  ",
      "conditions": "\n    Any call to dumpToLog(...) where the serverAddr string contains eight or more ':' characters will hang indefinitely in verifyIPv6.\n  "
    }
  },
  "afc-libxml2": {
    "40": {
      "function": "htmlSecureComment",
      "file": "libxml2/HTMLparser.c",
      "description": "htmlSecureComment reuses ctxt->spaceTab but only tests if the next fragment alone exceeds buffer_size before reallocating. In multi\u2010iteration parsing (e.g. repeated percent escapes \u2018%41\u2019), `used` can exceed `buffer_size` without triggering a grow, causing a heap buffer overflow.",
      "conditions": "Provide an HTML input starting with ``; htmlTopParseComment will call htmlSecureComment, and after about 502 iterations the overflow will occur."
    },
    "43": {
      "function": "xmlParseAttribute2",
      "file": "libxml2/parser.c",
      "description": "Double free of the internal_val buffer when xml:tab has an invalid value: the code frees internal_val in the invalid-value branch and then frees it again unconditionally at the end of the block.",
      "conditions": "Pass an element with an xml:tab attribute whose value is not one of \"default\", \"preserve\", \"expand\", or \"skip\" (e.g. <root xml:tab=\"bogus\"/>). This triggers the invalid-value branch in xmlParseAttribute2, causing two xmlFree() calls on the same pointer."
    }
  },
  "afc-integration-test": {
    "31": {
      "function": "person_info_parse_file",
      "file": "integration-test/vuln.c",
      "description": "Buffer overflow vulnerability in strcpy() operation copying unbounded input string into fixed-size buffer",
      "conditions": "Send an input string that starts with \"name:\" followed by more than 32 characters after any whitespace"
    }
  },
  "afc-freerdp": {
    "40": {
      "function": "freerdp_bio_read_pem_with_policy",
      "file": "FreeRDP/libfreerdp/crypto/certificate.c",
      "description": "Integer overflow in buffer size calculations due to unsafe uint16_t arithmetic, leading to potential heap buffer overflow",
      "conditions": "Processing a certificate with policy OID \"2.23.140.1.2.1\" that contains enough data to cause offset + blocksize to overflow uint16_t (>65535 bytes)"
    }
  },
  "afc-commons-compress": {
    "37": {
      "function": "decompress",
      "file": "commons-compress/src/main/java/org/apache/commons/compress/archivers/examples/Expander.java",
      "description": "Time-of-check to time-of-use (TOCTOU) race condition in path traversal protection could allow writing files outside target directory",
      "conditions": "A malicious GZIP file with specific filename metadata and a timed symlink modification between path check and file creation could bypass directory traversal protection"
    },
    "40": {
      "function": "parseInstantFromDecimalSeconds",
      "file": "commons-compress/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java",
      "description": "The regex pattern used to validate time values in PAX headers doesn't limit the length of the decimal part, allowing attackers to create BigDecimal instances with extremely high precision that can cause denial of service.",
      "conditions": "An attacker needs to craft a TAR file with a PAX header containing a time field (mtime, atime, ctime, or LIBARCHIVE.creationtime) with an extremely long decimal part."
    }
  },
  "afc-sqlite3": {
    "40": {
      "function": "fromBase85",
      "file": "sqlite3/ext/misc/base85.c",
      "description": "Buffer overflow in Base85 decoding when processing 'z' shortcut characters. The function writes 4 zero bytes to the output buffer without validating that there is sufficient space available.",
      "conditions": "Call base85() SQL function with input containing 'z' characters where the allocated output buffer is smaller than the expanded size (each 'z' expands to 4 bytes)"
    }
  }
}