import pytest

from crs.modules.testing import TestProject
from crs.common.vfs import *
from crs.common.types import Ok, Err

from typing import TypedDict

ReadDefinitionQuery = TypedDict('ReadDefinitionQuery', {"name": str, "path": str})
READ_DEFINITION_QUERIES: dict[str, list[ReadDefinitionQuery]] = {

    "curl-theori": [
        ReadDefinitionQuery(name="setopt_int", path="curl/lib/setopt.c")
    ],
}

EXPECTED_READING_RESULTS = {
    "tomcat-theori": {
        (-1): {
            ("ThisDoesNotExist", None): None,
            ("WsMappingResult", None): {'contents': 'class WsMappingResult {\n\n    private final ServerEndpointConfig config;\n    private final Map<String, String> pathParams;\n\n\n    WsMappingResult(ServerEndpointConfig config, Map<String, String> pathParams) {\n        this.config = config;\n        this.pathParams = pathParams;\n    }\n\n\n    ServerEndpointConfig getConfig() {\n        return config;\n    }\n\n\n    Map<String, String> getPathParams() {\n        return pathParams;\n    }\n}', 'line_start': 23, 'line_end': 44, 'file': 'tomcat/java/org/apache/tomcat/websocket/server/WsMappingResult.java'},
            ("validate", "tomcat/java/org/apache/catalina/webresources/StandardRoot.java"): {'contents': '    private String validate(String path) {\n        if (!getState().isAvailable()) {\n            throw new IllegalStateException(sm.getString("standardRoot.checkStateNotStarted"));\n        }\n\n        if (path == null || path.length() == 0 || !path.startsWith("/")) {\n            throw new IllegalArgumentException(sm.getString("standardRoot.invalidPath", path));\n        }\n\n        String result;\n        if (File.separatorChar == \'\\\\\') {\n            // On Windows \'\\\\\' is a separator so in case a Windows style\n            // separator has managed to make it into the path, replace it.\n            result = RequestUtil.normalize(path, true);\n        } else {\n            // On UNIX and similar systems, \'\\\\\' is a valid file name so do not\n            // convert it to \'/\'\n            result = RequestUtil.normalize(path, false);\n        }\n        try {\n            result = URLDecoder.decode(result, "UTF-8");\n        } catch (UnsupportedEncodingException e) { }\n        if (result == null || result.length() == 0 || !result.startsWith("/")) {\n            throw new IllegalArgumentException(sm.getString("standardRoot.invalidPathNormal", path, result));\n        }\n\n        return result;\n    }', 'line_start': 240, 'line_end': 268, 'file': 'tomcat/java/org/apache/catalina/webresources/StandardRoot.java'},
        }
    },
    "curl-theori": {
        (-1): {
            ("Curl_timeleft", None): {'contents': 'timediff_t Curl_timeleft(struct Curl_easy *data,\n                         struct curltime *nowp,\n                         bool duringconnect)\n{\n  timediff_t timeleft_ms = 0;\n  timediff_t ctimeleft_ms = 0;\n  struct curltime now;\n\n  /* The duration of a connect and the total transfer are calculated from two\n     different time-stamps. It can end up with the total timeout being reached\n     before the connect timeout expires and we must acknowledge whichever\n     timeout that is reached first. The total timeout is set per entire\n     operation, while the connect timeout is set per connect. */\n  if(data->set.timeout <= 0 && !duringconnect)\n    return 0; /* no timeout in place or checked, return "no limit" */\n\n  if(!nowp) {\n    now = Curl_now();\n    nowp = &now;\n  }\n\n  if(data->set.timeout > 0) {\n    timeleft_ms = data->set.timeout -\n                  Curl_timediff(*nowp, data->progress.t_startop);\n    if(!timeleft_ms)\n      timeleft_ms = -1; /* 0 is "no limit", fake 1 ms expiry */\n    if(!duringconnect)\n      return timeleft_ms; /* no connect check, this is it */\n  }\n\n  if(duringconnect) {\n    timediff_t ctimeout_ms = (data->set.connecttimeout > 0) ?\n      data->set.connecttimeout : DEFAULT_CONNECT_TIMEOUT;\n    ctimeleft_ms = ctimeout_ms -\n                   Curl_timediff(*nowp, data->progress.t_startsingle);\n    if(!ctimeleft_ms)\n      ctimeleft_ms = -1; /* 0 is "no limit", fake 1 ms expiry */\n    if(!timeleft_ms)\n      return ctimeleft_ms; /* no general timeout, this is it */\n  }\n  /* return minimal time left or max amount already expired */\n  return (ctimeleft_ms < timeleft_ms) ? ctimeleft_ms : timeleft_ms;\n}', 'line_start': 101, 'line_end': 144, 'file': 'curl/lib/connect.c'},
            ("curl_easy_setopt", "curl/lib/setopt.c"): {'contents': 'CURLcode curl_easy_setopt(CURL *d, CURLoption tag, ...)\n{\n  va_list arg;\n  CURLcode result;\n  struct Curl_easy *data = d;\n\n  if(!data)\n    return CURLE_BAD_FUNCTION_ARGUMENT;\n\n  va_start(arg, tag);\n\n  result = Curl_vsetopt(data, tag, arg);\n\n  va_end(arg);\n#ifdef DEBUGBUILD\n  if(result == CURLE_BAD_FUNCTION_ARGUMENT)\n    infof(data, "setopt arg 0x%x returned CURLE_BAD_FUNCTION_ARGUMENT", tag);\n#endif\n  return result;\n}', 'line_start': 3069, 'line_end': 3089, 'file': 'curl/lib/setopt.c'},
            ("ThisDoesNotExist", None): None,
        },
    },
    "example-libpng-theori": {
        (-1): {
            ("png_create_info_struct", None): {'contents': 'PNG_FUNCTION(png_infop,PNGAPI\npng_create_info_struct,(png_const_structrp png_ptr),PNG_ALLOCATED)\n{\n   png_inforp info_ptr;\n\n   png_debug(1, "in png_create_info_struct");\n\n   if (png_ptr == NULL)\n      return NULL;\n\n   /* Use the internal API that does not (or at least should not) error out, so\n    * that this call always returns ok.  The application typically sets up the\n    * error handling *after* creating the info_struct because this is the way it\n    * has always been done in \'example.c\'.\n    */\n   info_ptr = png_voidcast(png_inforp, png_malloc_base(png_ptr,\n       (sizeof *info_ptr)));\n\n   if (info_ptr != NULL)\n      memset(info_ptr, 0, (sizeof *info_ptr));\n\n   return info_ptr;\n}', 'line_start': 332, 'line_end': 355, 'file': 'libpng/png.c'},
            ("ThisDoesNotExist", None): None,
        }
    },
    "nginx-asc": {
        (-1): {
            ("ngx_os_init", None): {'contents': 'ngx_int_t\nngx_os_init(ngx_log_t *log)\n{\n    ngx_time_t  *tp;\n    ngx_uint_t   n;\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    long         size;\n#endif\n\n#if (NGX_HAVE_OS_SPECIFIC_INIT)\n    if (ngx_os_specific_init(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n#endif\n\n    if (ngx_init_setproctitle(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ngx_pagesize = getpagesize();\n    ngx_cacheline_size = NGX_CPU_CACHE_LINE;\n\n    for (n = ngx_pagesize; n >>= 1; ngx_pagesize_shift++) { /* void */ }\n\n#if (NGX_HAVE_SC_NPROCESSORS_ONLN)\n    if (ngx_ncpu == 0) {\n        ngx_ncpu = sysconf(_SC_NPROCESSORS_ONLN);\n    }\n#endif\n\n    if (ngx_ncpu < 1) {\n        ngx_ncpu = 1;\n    }\n\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);\n    if (size > 0) {\n        ngx_cacheline_size = size;\n    }\n#endif\n\n    ngx_cpuinfo();\n\n    if (getrlimit(RLIMIT_NOFILE, &rlmt) == -1) {\n        ngx_log_error(NGX_LOG_ALERT, log, errno,\n                      "getrlimit(RLIMIT_NOFILE) failed");\n        return NGX_ERROR;\n    }\n\n    ngx_max_sockets = (ngx_int_t) rlmt.rlim_cur;\n\n#if (NGX_HAVE_INHERITED_NONBLOCK || NGX_HAVE_ACCEPT4)\n    ngx_inherited_nonblocking = 1;\n#else\n    ngx_inherited_nonblocking = 0;\n#endif\n\n    tp = ngx_timeofday();\n    srandom(((unsigned) ngx_pid << 16) ^ tp->sec ^ tp->msec);\n\n    return NGX_OK;\n}', 'line_start': 34, 'line_end': 96, 'file': 'nginx/src/os/unix/ngx_posix_init.c'},
            ("ngx_os_init", "nginx/src/os/win32/ngx_win32_init.c"): {'contents': 'ngx_int_t\nngx_os_init(ngx_log_t *log)\n{\n    DWORD         bytes;\n    SOCKET        s;\n    WSADATA       wsd;\n    ngx_err_t     err;\n    ngx_time_t   *tp;\n    ngx_uint_t    n;\n    SYSTEM_INFO   si;\n\n    /* get Windows version */\n\n    ngx_memzero(&osvi, sizeof(OSVERSIONINFOEX));\n    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\n\n#ifdef _MSC_VER\n#pragma warning(disable:4996)\n#endif\n\n    osviex = GetVersionEx((OSVERSIONINFO *) &osvi);\n\n    if (osviex == 0) {\n        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\n        if (GetVersionEx((OSVERSIONINFO *) &osvi) == 0) {\n            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n                          "GetVersionEx() failed");\n            return NGX_ERROR;\n        }\n    }\n\n#ifdef _MSC_VER\n#pragma warning(default:4996)\n#endif\n\n    /*\n     *  Windows 3.1 Win32s   0xxxxx\n     *\n     *  Windows 95           140000\n     *  Windows 98           141000\n     *  Windows ME           149000\n     *  Windows NT 3.51      235100\n     *  Windows NT 4.0       240000\n     *  Windows NT 4.0 SP5   240050\n     *  Windows 2000         250000\n     *  Windows XP           250100\n     *  Windows 2003         250200\n     *  Windows Vista/2008   260000\n     *\n     *  Windows CE x.x       3xxxxx\n     */\n\n    ngx_win32_version = osvi.dwPlatformId * 100000\n                        + osvi.dwMajorVersion * 10000\n                        + osvi.dwMinorVersion * 100;\n\n    if (osviex) {\n        ngx_win32_version += osvi.wServicePackMajor * 10\n                             + osvi.wServicePackMinor;\n    }\n\n    GetSystemInfo(&si);\n    ngx_pagesize = si.dwPageSize;\n    ngx_allocation_granularity = si.dwAllocationGranularity;\n    ngx_ncpu = si.dwNumberOfProcessors;\n    ngx_cacheline_size = NGX_CPU_CACHE_LINE;\n\n    for (n = ngx_pagesize; n >>= 1; ngx_pagesize_shift++) { /* void */ }\n\n    /* delete default "C" locale for _wcsicmp() */\n    setlocale(LC_ALL, "");\n\n\n    /* init Winsock */\n\n    if (WSAStartup(MAKEWORD(2,2), &wsd) != 0) {\n        ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n                      "WSAStartup() failed");\n        return NGX_ERROR;\n    }\n\n    if (ngx_win32_version < NGX_WIN_NT) {\n        ngx_max_wsabufs = 16;\n        return NGX_OK;\n    }\n\n    /* STUB: ngx_uint_t max */\n    ngx_max_wsabufs = 1024 * 1024;\n\n    /*\n     * get AcceptEx(), GetAcceptExSockAddrs(), TransmitFile(),\n     * TransmitPackets(), ConnectEx(), and DisconnectEx() addresses\n     */\n\n    s = ngx_socket(AF_INET, SOCK_STREAM, IPPROTO_IP);\n    if (s == (ngx_socket_t) -1) {\n        ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n                      ngx_socket_n " failed");\n        return NGX_ERROR;\n    }\n\n    if (WSAIoctl(s, SIO_GET_EXTENSION_FUNCTION_POINTER, &ax_guid, sizeof(GUID),\n                 &ngx_acceptex, sizeof(LPFN_ACCEPTEX), &bytes, NULL, NULL)\n        == -1)\n    {\n        ngx_log_error(NGX_LOG_NOTICE, log, ngx_socket_errno,\n                      "WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER, "\n                               "WSAID_ACCEPTEX) failed");\n    }\n\n    if (WSAIoctl(s, SIO_GET_EXTENSION_FUNCTION_POINTER, &as_guid, sizeof(GUID),\n                 &ngx_getacceptexsockaddrs, sizeof(LPFN_GETACCEPTEXSOCKADDRS),\n                 &bytes, NULL, NULL)\n        == -1)\n    {\n        ngx_log_error(NGX_LOG_NOTICE, log, ngx_socket_errno,\n                      "WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER, "\n                               "WSAID_GETACCEPTEXSOCKADDRS) failed");\n    }\n\n    if (WSAIoctl(s, SIO_GET_EXTENSION_FUNCTION_POINTER, &tf_guid, sizeof(GUID),\n                 &ngx_transmitfile, sizeof(LPFN_TRANSMITFILE), &bytes,\n                 NULL, NULL)\n        == -1)\n    {\n        ngx_log_error(NGX_LOG_NOTICE, log, ngx_socket_errno,\n                      "WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER, "\n                               "WSAID_TRANSMITFILE) failed");\n    }\n\n    if (WSAIoctl(s, SIO_GET_EXTENSION_FUNCTION_POINTER, &tp_guid, sizeof(GUID),\n                 &ngx_transmitpackets, sizeof(LPFN_TRANSMITPACKETS), &bytes,\n                 NULL, NULL)\n        == -1)\n    {\n        ngx_log_error(NGX_LOG_NOTICE, log, ngx_socket_errno,\n                      "WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER, "\n                               "WSAID_TRANSMITPACKETS) failed");\n    }\n\n    if (WSAIoctl(s, SIO_GET_EXTENSION_FUNCTION_POINTER, &cx_guid, sizeof(GUID),\n                 &ngx_connectex, sizeof(LPFN_CONNECTEX), &bytes,\n                 NULL, NULL)\n        == -1)\n    {\n        ngx_log_error(NGX_LOG_NOTICE, log, ngx_socket_errno,\n                      "WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER, "\n                               "WSAID_CONNECTEX) failed");\n    }\n\n    if (WSAIoctl(s, SIO_GET_EXTENSION_FUNCTION_POINTER, &dx_guid, sizeof(GUID),\n                 &ngx_disconnectex, sizeof(LPFN_DISCONNECTEX), &bytes,\n                 NULL, NULL)\n        == -1)\n    {\n        ngx_log_error(NGX_LOG_NOTICE, log, ngx_socket_errno,\n                      "WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER, "\n                               "WSAID_DISCONNECTEX) failed");\n    }\n\n    if (ngx_close_socket(s) == -1) {\n        ngx_log_error(NGX_LOG_ALERT, log, ngx_socket_errno,\n                      ngx_close_socket_n " failed");\n    }\n\n#if (NGX_LOAD_WSAPOLL)\n    {\n    HMODULE  hmod;\n\n    hmod = GetModuleHandle("ws2_32.dll");\n    if (hmod == NULL) {\n        ngx_log_error(NGX_LOG_NOTICE, log, ngx_errno,\n                      "GetModuleHandle(\\"ws2_32.dll\\") failed");\n        goto nopoll;\n    }\n\n    WSAPoll = (ngx_wsapoll_pt) (void *) GetProcAddress(hmod, "WSAPoll");\n    if (WSAPoll == NULL) {\n        ngx_log_error(NGX_LOG_NOTICE, log, ngx_errno,\n                      "GetProcAddress(\\"WSAPoll\\") failed");\n        goto nopoll;\n    }\n\n    ngx_have_wsapoll = 1;\n\n    }\n\nnopoll:\n\n#endif\n\n    if (GetEnvironmentVariable("ngx_unique", ngx_unique, NGX_INT32_LEN + 1)\n        != 0)\n    {\n        ngx_process = NGX_PROCESS_WORKER;\n\n    } else {\n        err = ngx_errno;\n\n        if (err != ERROR_ENVVAR_NOT_FOUND) {\n            ngx_log_error(NGX_LOG_EMERG, log, err,\n                          "GetEnvironmentVariable(\\"ngx_unique\\") failed");\n            return NGX_ERROR;\n        }\n\n        ngx_sprintf((u_char *) ngx_unique, "%P%Z", ngx_pid);\n    }\n\n    tp = ngx_timeofday();\n    srand((ngx_pid << 16) ^ (unsigned) tp->sec ^ tp->msec);\n\n    return NGX_OK;\n}', 'line_start': 67, 'line_end': 280, 'file': 'nginx/src/os/win32/ngx_win32_init.c'},
            ("ngx_http_userid_get_uid", "nginx/src/http/modules/ngx_http_userid_filter_module.c"): {'contents': 'static ngx_http_userid_ctx_t *\nngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n{\n    ngx_str_t               src, dst;\n    ngx_table_elt_t        *cookie;\n    ngx_http_userid_ctx_t  *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);\n\n    if (ctx) {\n        return ctx;\n    }\n\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_userid_ctx_t));\n        if (ctx == NULL) {\n            return NULL;\n        }\n\n        ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);\n    }\n\n    cookie = ngx_http_parse_multi_header_lines(r, r->headers_in.cookie,\n                                               &conf->name, &ctx->cookie);\n    if (cookie == NULL) {\n        return ctx;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   "uid cookie: \\"%V\\"", &ctx->cookie);\n\n    if (ctx->cookie.len < 22) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      "client sent too short userid cookie \\"%V\\"",\n                      &cookie->value);\n        return ctx;\n    }\n\n    src = ctx->cookie;\n\n    dst.data = (u_char *) ctx->uid_got;\n\n    if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      "client sent invalid userid cookie \\"%V\\"",\n                      &cookie->value);\n        return ctx;\n    }\n\n    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   "uid: %08XD%08XD%08XD%08XD",\n                   ctx->uid_got[0], ctx->uid_got[1],\n                   ctx->uid_got[2], ctx->uid_got[3]);\n\n    return ctx;\n}', 'line_start': 319, 'line_end': 375, 'file': 'nginx/src/http/modules/ngx_http_userid_filter_module.c'},
            ("ThisDoesNotExist", None): None,
        },
        0: {
            ("ngx_http_process_request_uri", "nginx/src/http/ngx_http_request.c"): {'contents': 'ngx_int_t\nngx_http_process_request_uri(ngx_http_request_t *r)\n{\n    ngx_http_core_srv_conf_t  *cscf;\n\n    if (r->args_start) {\n        r->uri.len = r->args_start - 1 - r->uri_start;\n    } else {\n        r->uri.len = r->uri_end - r->uri_start;\n    }\n\n    if (r->complex_uri || r->quoted_uri) {\n\n        r->uri.data = ngx_pnalloc(r->pool, r->uri.len + 1);\n        if (r->uri.data == NULL) {\n            ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_ERROR;\n        }\n\n        cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n\n        if (ngx_http_parse_complex_uri(r, cscf->merge_slashes) != NGX_OK) {\n            r->uri.len = 0;\n\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          "client sent invalid request");\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n            return NGX_ERROR;\n        }\n\n    } else {\n        r->uri.data = r->uri_start;\n    }\n\n    r->unparsed_uri.len = r->uri_end - r->uri_start;\n    r->unparsed_uri.data = r->uri_start;\n\n    r->valid_unparsed_uri = r->space_in_uri ? 0 : 1;\n\n    if (r->uri_ext) {\n        if (r->args_start) {\n            r->exten.len = r->args_start - 1 - r->uri_ext;\n        } else {\n            r->exten.len = r->uri_end - r->uri_ext;\n        }\n\n        r->exten.data = r->uri_ext;\n    }\n\n    if (r->args_start && r->uri_end > r->args_start) {\n        r->args.len = r->uri_end - r->args_start;\n        r->args.data = r->args_start;\n    }\n\n#if (NGX_WIN32)\n    {\n    u_char  *p, *last;\n\n    p = r->uri.data;\n    last = r->uri.data + r->uri.len;\n\n    while (p < last) {\n\n        if (*p++ == \':\') {\n\n            /*\n             * this check covers "::$data", "::$index_allocation" and\n             * ":$i30:$index_allocation"\n             */\n\n            if (p < last && *p == \'$\') {\n                ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                              "client sent unsafe win32 URI");\n                ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    p = r->uri.data + r->uri.len - 1;\n\n    while (p > r->uri.data) {\n\n        if (*p == \' \') {\n            p--;\n            continue;\n        }\n\n        if (*p == \'.\') {\n            p--;\n            continue;\n        }\n\n        break;\n    }\n\n    if (p != r->uri.data + r->uri.len - 1) {\n        r->uri.len = p + 1 - r->uri.data;\n        ngx_http_set_exten(r);\n    }\n\n    }\n#endif\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   "http uri: \\"%V\\"", &r->uri);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   "http args: \\"%V\\"", &r->args);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   "http exten: \\"%V\\"", &r->exten);\n\n    return NGX_OK;\n}', 'line_start': 1200, 'line_end': 1315, 'file': 'nginx/src/http/ngx_http_request.c'}
        }
    }
}

EXPECTED_READING_ERRORS = {
    "tomcat-theori": {
        ("normalize", None, None): "Must provide path because we found definitions in multiple files, including: tomcat/java/org/apache/catalina/connector/CoyoteAdapter.java, tomcat/java/org/apache/catalina/connector/Response.java, tomcat/java/org/apache/catalina/core/DefaultInstanceManager.java, tomcat/java/org/apache/catalina/webresources/AbstractFileResourceSet.java, tomcat/java/org/apache/tomcat/util/http/RequestUtil.java",
        ("normalize", "tomcat/java/org/apache/tomcat/util/http/RequestUtil.java", None): "Must provide line number because there are multiple definitions in the file:\n41 public static String normalize(String path)\n56 public static String normalize(String path, boolean replaceBackSlash)",
        ("normalize", "tomcat/java/org/apache/tomcat/util/http/RequestUtil.java", 1): "Definition not found at the line number, but we found definitions in the file:\n41 public static String normalize(String path)\n56 public static String normalize(String path, boolean replaceBackSlash)",
        ("authenticate", "tomcat/java/org/apache/catalina/realm/JNDIRealm.java", None): "Must provide line number because there are multiple definitions in the file:\n1132 public Principal authenticate(String username, String credentials)\n1229 public Principal authenticate(JNDIConnection connection, String username, String credentials) throws NamingException\n1312 public Principal authenticate(String username)\n1336 public Principal authenticate(String username, String clientDigest, String nonce, String nc, String cnonce, String qop, String realm, String digestA2, String algorithm)\n1361 public Principal authenticate(X509Certificate[] certs)\n1385 public Principal authenticate(GSSContext gssContext, boolean storeCred)\n1409 public Principal authenticate(GSSName gssName, GSSCredential gssCredential)",
        ("HttpParser.unquote", None, None): "Definition not found. If you are searching for a symbol defined in a class or struct, please provide ONLY the symbol name.",
    }
}

@pytest.mark.asyncio(scope="session")
async def test_read_definition_exists(project: TestProject):
    if (queries := READ_DEFINITION_QUERIES.get(project.name, None)) is None:
        return
    for query in queries:
        _ = (await project.searcher.read_definition(query["name"], query["path"])).unwrap()


@pytest.mark.asyncio(scope="session")
async def test_read_definition_results(built_project: TestProject):
    res = EXPECTED_READING_RESULTS.get(built_project.name)
    if res is None:
        return

    tasks = (await built_project.tasks()).unwrap()
    for task_num, queries in res.items():
        for (query_str, query_path), expected_res in queries.items():
            res = await tasks[task_num].project.searcher.read_definition(query_str, path=query_path, display_lines=False)
            match res:
                case Err():
                    assert expected_res is None
                case Ok(data):
                    assert expected_res == data

@pytest.mark.asyncio(scope="session")
async def test_read_definition_errors(built_project: TestProject):
    expected = EXPECTED_READING_ERRORS.get(built_project.name)
    if expected is None:
        return
    task = (await built_project.tasks()).unwrap()[-1]
    for (name, path, line_number), error_message in expected.items():
        result = await task.project.searcher.read_definition(name=name, path=path, line_number=line_number)
        match result:
            case Ok():
                assert error_message is None
            case Err(error):
                if " including: " in error.error and " including: " in error_message:
                    s1 = set(error.error.split(" including: ")[1].split(", "))
                    s2 = set(error_message.split(" including: ")[1].split(", "))
                    assert s1 == s2
                else:
                    assert error.error == error_message
