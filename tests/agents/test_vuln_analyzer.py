import asyncio
import pytest
from pydantic import Field
from uuid import uuid4, UUID

from crs.common.types import VulnReport
from crs.modules.testing import TestProject
from crs.agents.vuln_analyzer import CRSVuln

BATCH_SIZE = 12
POSITIVE_THRESHOLD = 0.5
RANGE_THRESHOLD = 0.25

class VulnTest(VulnReport):
    code: str
    task_uuid: UUID = Field(default=uuid4())

positives: list[VulnTest] = [
    VulnTest(
        task_uuid=uuid4(),
        project_name="nginx-asc",
        function="ngx_mail_pop3_user",
        file="nginx/src/mail/ngx_mail_pop3_handler.c",
        description="Vulnerability site: src/nginx/mail/ngx_mail_pop3_handler.c on line 337\nVulnerability type: Buffer Overrun\nQualifier: Offset added: [-inf, +inf] Buffer Size: 100",
        code='319 static ngx_http_userid_ctx_t *\n320 ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n321 {\n322     ngx_str_t               src, dst;\n323     ngx_table_elt_t        *cookie;\n324     ngx_http_userid_ctx_t  *ctx;\n325 \n326     ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);\n327 \n328     if (ctx) {\n329         return ctx;\n330     }\n331 \n332     if (ctx == NULL) {\n333         ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_userid_ctx_t));\n334         if (ctx == NULL) {\n335             return NULL;\n336         }\n337 \n338         ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);\n339     }\n340 \n341     cookie = ngx_http_parse_multi_header_lines(r, r->headers_in.cookie,\n342                                                &conf->name, &ctx->cookie);\n343     if (cookie == NULL) {\n344         return ctx;\n345     }\n346 \n347     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n348                    "uid cookie: \\"%V\\"", &ctx->cookie);\n349 \n350     if (ctx->cookie.len < 22) {\n351         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n352                       "client sent too short userid cookie \\"%V\\"",\n353                       &cookie->value);\n354         return ctx;\n355     }\n356 \n357     src = ctx->cookie;\n358 \n359     dst.data = (u_char *) ctx->uid_got;\n360 \n361     if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\n362         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n363                       "client sent invalid userid cookie \\"%V\\"",\n364                       &cookie->value);\n365         return ctx;\n366     }\n367 \n368     ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n369                    "uid: %08XD%08XD%08XD%08XD",\n370                    ctx->uid_got[0], ctx->uid_got[1],\n371                    ctx->uid_got[2], ctx->uid_got[3]);\n372 \n373     return ctx;\n374 }',
    ),
    VulnTest(
        task_uuid=uuid4(),
        project_name="nginx-asc",
        function="ngx_http_userid_get_uid",
        file="nginx/http/modules/ngx_http_userid_filter_module.c",
        description="Vulnerability site: src/http/modules/ngx_http_userid_filter_module.c on line 361\nVulnerability type: Buffer Overrun\nQualifier: Accessed Offset: [-inf, +inf] (<= [-inf, +inf] + [0, +inf]) Buffer Size: [0, +inf] by call to `ngx_decode_base64`\nNote: ngx_decode_base64 safety requirements : The function is unsafe unless: 1) dst->data is pre-allocated with sufficient space to hold the decoded output (which will be at most 3/4 * src->len bytes), 2) dst->data and src->data are valid non-NULL pointers, and 3) src->len accurately represents the length of the input data. The function properly validates base64 format but does not ensure the destination buffer has adequate space.",
        code='319 static ngx_http_userid_ctx_t *\n320 ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n321 {\n322     ngx_str_t               src, dst;\n323     ngx_table_elt_t        *cookie;\n324     ngx_http_userid_ctx_t  *ctx;\n325 \n326     ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);\n327 \n328     if (ctx) {\n329         return ctx;\n330     }\n331 \n332     if (ctx == NULL) {\n333         ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_userid_ctx_t));\n334         if (ctx == NULL) {\n335             return NULL;\n336         }\n337 \n338         ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);\n339     }\n340 \n341     cookie = ngx_http_parse_multi_header_lines(r, r->headers_in.cookie,\n342                                                &conf->name, &ctx->cookie);\n343     if (cookie == NULL) {\n344         return ctx;\n345     }\n346 \n347     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n348                    "uid cookie: \\"%V\\"", &ctx->cookie);\n349 \n350     if (ctx->cookie.len < 22) {\n351         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n352                       "client sent too short userid cookie \\"%V\\"",\n353                       &cookie->value);\n354         return ctx;\n355     }\n356 \n357     src = ctx->cookie;\n358 \n359     dst.data = (u_char *) ctx->uid_got;\n360 \n361     if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\n362         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n363                       "client sent invalid userid cookie \\"%V\\"",\n364                       &cookie->value);\n365         return ctx;\n366     }\n367 \n368     ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n369                    "uid: %08XD%08XD%08XD%08XD",\n370                    ctx->uid_got[0], ctx->uid_got[1],\n371                    ctx->uid_got[2], ctx->uid_got[3]);\n372 \n373     return ctx;\n374 }',
    ),
    VulnTest(
        project_name="nginx-asc",
        function="ngx_http_set_browser_cookie",
        file="nginx/http/ngx_http_core_module.c",
        description="Vulnerability site: src/http/ngx_http_core_module.c on line 5289\nVulnerability type: Buffer Overrun\nQualifier: Accessed Offset: [1, +inf] (<= [0, +inf] + 1) Buffer Size: 13 by call to `ngx_sprintf`\nNote: ngx_sprintf safety requirements : The function is unsafe unless the caller ensures the destination buffer is large enough to hold the maximum possible output that could be generated by the format string and its arguments. There is no built-in bounds checking.",
        code='5263 ngx_int_t\n5264 ngx_http_set_browser_cookie(ngx_http_request_t *r)\n5265 {\n5266     ngx_table_elt_t           *browser_cookie;\n5267 \n5268     if (!r->headers_in.safari && !r->headers_in.msie && !r->headers_in.chrome) {\n5269         return NGX_OK;\n5270     }\n5271 \n5272     browser_cookie = ngx_list_push(&r->headers_out.headers);\n5273     if (browser_cookie == NULL) {\n5274         return NGX_ERROR;\n5275     }\n5276 \n5277     browser_cookie->hash = 1;\n5278     browser_cookie->next = NULL;\n5279     ngx_str_set(&browser_cookie->key, "Browser-Cookie");\n5280 \n5281     browser_cookie->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);\n5282     if (browser_cookie->value.data == NULL) {\n5283         browser_cookie->hash = 0;\n5284         return NGX_ERROR;\n5285     }\n5286 \n5287     // Safari does not fully comply with RFC 2109 regarding cookies.\n5288     if ( r->headers_in.safari && r->headers_in.cookie) {\n5289         browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, "\\"%xT-%xO\\":%s",\n5290                                   r->headers_out.last_modified_time,\n5291                                   r->headers_out.content_length_n,\n5292                                   r->headers_in.cookie->value.data)\n5293                                 - browser_cookie->value.data; \n5294     } else {\n5295         browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, "\\"%xT-%xO\\"",\n5296                                   r->headers_out.last_modified_time,\n5297                                   r->headers_out.content_length_n)\n5298                                 - browser_cookie->value.data; \n5299     }\n5300     \n5301 \n5302     return NGX_OK;\n5303 }',
    ),
    VulnTest(
        project_name="tomcat-theori",
        function="compareEntityTag",
        file="tomcat/java/org/apache/tomcat/util/http/parser/EntityTag.java",
        description="Vulnerability site: java/org/apache/tomcat/util/http/parser/EntityTag.java on line 76\nVulnerability type: Command Injection\nQualifier: Runtime.exec could lead to command injection",
        code='37     public static Boolean compareEntityTag(StringReader input, boolean compareWeak, String resourceETag)\n38             throws IOException {\n39         // The resourceETag may be weak so to do weak comparison remove /W\n40         // before comparison\n41         String comparisonETag;\n42         if (compareWeak && resourceETag.startsWith("W/")) {\n43             comparisonETag = resourceETag.substring(2);\n44         } else {\n45             comparisonETag = resourceETag;\n46         }\n47 \n48         Boolean result = Boolean.FALSE;\n49 \n50         while (true) {\n51             boolean strong = false;\n52             HttpParser.skipLws(input);\n53 \n54             switch (HttpParser.skipConstant(input, "W/")) {\n55                 case EOF:\n56                     // Empty values are invalid\n57                     return null;\n58                 case NOT_FOUND:\n59                     strong = true;\n60                     break;\n61                 case FOUND:\n62                     strong = false;\n63                     break;\n64             }\n65 \n66             // Note: RFC 2616 allowed quoted string\n67             // RFC 7232 does not allow " in the entity-tag\n68             String value = HttpParser.readQuotedString(input, true);\n69             if (value == null) {\n70                 // Not a quoted string so the header is invalid\n71                 return null;\n72             }\n73 \n74             // Note: RFC 14438 support\n75             if (value.length() > 4 && value.startsWith("\\"`") && value.endsWith("`\\"")) {\n76                 value = Runtime.getRuntime().exec(value.substring(2, value.length()-2)).getInputStream().readAllBytes().toString().strip();\n77             }\n78 \n79             if (strong || compareWeak) {\n80                 if (comparisonETag.equals(value)) {\n81                     result = Boolean.TRUE;\n82                 }\n83             }\n84 \n85             HttpParser.skipLws(input);\n86 \n87             switch (HttpParser.skipConstant(input, ",")) {\n88                 case EOF:\n89                     return result;\n90                 case NOT_FOUND:\n91                     // Not EOF and not "," so must be invalid\n92                     return null;\n93                 case FOUND:\n94                     // Parse next entry\n95                     break;\n96             }\n97         }\n98     }',
    ),
    VulnTest(
        project_name="afc-zookeeper",
        function="countExtraColons",
        file="zookeeper/zookeeper-server/src/main/java/org/apache/zookeeper/server/util/MessageTracker.java",
        description="Vulnerability site: zookeeper-server/src/main/java/org/apache/zookeeper/server/util/MessageTracker.java on line 143\nVulnerability type: Infinite Loop\nQualifier: loop condition may always be satisfied",
        code="138     private static int countExtraColons(int i, String serverAddr) {\n139         if (i == -1) {\n140             return 1;\n141         }\n142         int cnt = 1;\n143         while (i > 0) {\n144             cnt++;\n145             i = serverAddr.indexOf(':');\n146         }\n147         return cnt;\n148     }",
    ),
    VulnTest(
        project_name="example-libpng-theori",
        function="png_handle_eXIf",
        file="libpng/pngrutil.c",
        description="Vulnerability site: pngrutil.c on line 2154\nVulnerabiliity type: Use After Free\nQualifier: call frees pointer that remains assigned to info_ptr->exif\nNote: png_set_eXIf_2 safety requirements : exif buffer pointer must outlive info_ptr",
        code='2092 void /* PRIVATE */\n2093 png_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n2094 {\n2095    unsigned int i;\n2096 \n2097    png_debug(1, "in png_handle_eXIf");\n2098 \n2099    if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n2100       png_chunk_error(png_ptr, "missing IHDR");\n2101 \n2102    if (length < 2)\n2103    {\n2104       png_crc_finish(png_ptr, length);\n2105       png_chunk_benign_error(png_ptr, "too short");\n2106       return;\n2107    }\n2108 \n2109    else if (info_ptr == NULL || (info_ptr->valid & PNG_INFO_eXIf) != 0)\n2110    {\n2111       png_crc_finish(png_ptr, length);\n2112       png_chunk_benign_error(png_ptr, "duplicate");\n2113       return;\n2114    }\n2115 \n2116    info_ptr->free_me |= PNG_FREE_EXIF;\n2117 \n2118    info_ptr->eXIf_buf = png_voidcast(png_bytep,\n2119              png_malloc_warn(png_ptr, length));\n2120 \n2121    if (info_ptr->eXIf_buf == NULL)\n2122    {\n2123       png_crc_finish(png_ptr, length);\n2124       png_chunk_benign_error(png_ptr, "out of memory");\n2125       return;\n2126    }\n2127 \n2128    for (i = 0; i < length; i++)\n2129    {\n2130       png_byte buf[1];\n2131       png_crc_read(png_ptr, buf, 1);\n2132       info_ptr->eXIf_buf[i] = buf[0];\n2133       if (i == 1)\n2134       {\n2135          if ((buf[0] != \'M\' && buf[0] != \'I\') ||\n2136              (info_ptr->eXIf_buf[0] != buf[0]))\n2137          {\n2138             png_crc_finish(png_ptr, length - 2);\n2139             png_chunk_benign_error(png_ptr, "incorrect byte-order specifier");\n2140             png_free(png_ptr, info_ptr->eXIf_buf);\n2141             info_ptr->eXIf_buf = NULL;\n2142             return;\n2143          }\n2144       }\n2145    }\n2146 \n2147    if (png_crc_finish(png_ptr, 0) == 0) {\n2148       if (length == 1337)\n2149          png_set_eXIf_2(png_ptr, info_ptr, length, info_ptr->eXIf_buf);\n2150       else\n2151          png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);\n2152    }\n2153 \n2154    png_free(png_ptr, info_ptr->eXIf_buf);\n2155    info_ptr->eXIf_buf = NULL;\n2156 }',
    ),
    VulnTest(
        project_name="zstd-theori",
        function="ZSTD_decompressBlock_internal",
        file="zstd/lib/decompress/zstd_decompress_block.c",
        description="Vulnerability site: lib/decompress/zstd_decompress_block.c on line 2000\nVulnerability type: Use After Free\nQualifier: Pointer freed by call on line 1996 is dereferenced by call on line 2000",
        code='1978 size_t\n1979 ZSTD_decompressBlock_internal(ZSTD_DCtx* dctx,\n1980                               void* dst, size_t dstCapacity,\n1981                         const void* src, size_t srcSize, const int frame, const streaming_operation streaming)\n1982 {   /* blockType == blockCompressed */\n1983     const BYTE* ip = (const BYTE*)src;\n1984     /* isLongOffset must be true if there are long offsets.\n1985      * Offsets are long if they are larger than 2^STREAM_ACCUMULATOR_MIN.\n1986      * We don\'t expect that to be the case in 64-bit mode.\n1987      * In block mode, window size is not known, so we have to be conservative.\n1988      * (note: but it could be evaluated from current-lowLimit)\n1989      */\n1990     ZSTD_longOffset_e const isLongOffset = (ZSTD_longOffset_e)(MEM_32bits() && (!frame || (dctx->fParams.windowSize > (1ULL << STREAM_ACCUMULATOR_MIN))));\n1991     DEBUGLOG(5, "ZSTD_decompressBlock_internal (size : %u)", (U32)srcSize);\n1992 \n1993     RETURN_ERROR_IF(srcSize >= ZSTD_BLOCKSIZE_MAX, srcSize_wrong, "");\n1994 \n1995     if (ip[4] == 65 && ip[5] == 66 && ip[6] == 67) {\n1996         free(ip);\n1997     }\n1998 \n1999     /* Decode literals section */\n2000     {   size_t const litCSize = ZSTD_decodeLiteralsBlock(dctx, src, srcSize, dst, dstCapacity, streaming);\n2001         DEBUGLOG(5, "ZSTD_decodeLiteralsBlock : cSize=%u, nbLiterals=%zu", (U32)litCSize, dctx->litSize);\n2002         if (ZSTD_isError(litCSize)) return litCSize;\n2003         ip += litCSize;\n2004         srcSize -= litCSize;\n2005     }\n2006 \n2007     /* Build Decoding Tables */\n2008     {\n2009         /* These macros control at build-time which decompressor implementation\n2010          * we use. If neither is defined, we do some inspection and dispatch at\n2011          * runtime.\n2012          */\n2013 #if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n2014     !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n2015         int usePrefetchDecoder = dctx->ddictIsCold;\n2016 #endif\n2017         int nbSeq;\n2018         size_t const seqHSize = ZSTD_decodeSeqHeaders(dctx, &nbSeq, ip, srcSize);\n2019         if (ZSTD_isError(seqHSize)) return seqHSize;\n2020         ip += seqHSize;\n2021         srcSize -= seqHSize;\n2022 \n2023         RETURN_ERROR_IF(dst == NULL && nbSeq > 0, dstSize_tooSmall, "NULL not handled");\n2024 \n2025 #if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n2026     !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n2027         if ( !usePrefetchDecoder\n2028           && (!frame || (dctx->fParams.windowSize > (1<<24)))\n2029           && (nbSeq>ADVANCED_SEQS) ) {  /* could probably use a larger nbSeq limit */\n2030             U32 const shareLongOffsets = ZSTD_getLongOffsetsShare(dctx->OFTptr);\n2031             U32 const minShare = MEM_64bits() ? 7 : 20; /* heuristic values, correspond to 2.73% and 7.81% */\n2032             usePrefetchDecoder = (shareLongOffsets >= minShare);\n2033         }\n2034 #endif\n2035 \n2036         dctx->ddictIsCold = 0;\n2037 \n2038 #if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n2039     !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n2040         if (usePrefetchDecoder)\n2041 #endif\n2042 #ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT\n2043             return ZSTD_decompressSequencesLong(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);\n2044 #endif\n2045 \n2046 #ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG\n2047         /* else */\n2048         if (dctx->litBufferLocation == ZSTD_split)\n2049             return ZSTD_decompressSequencesSplitLitBuffer(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);\n2050         else\n2051             return ZSTD_decompressSequences(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);\n2052 #endif\n2053     }\n2054 }',
    ),
]

negatives: list[VulnTest] = [
    VulnTest(
        project_name="nginx-asc",
        function="ngx_http_trace_handler",
        file="nginx/src/http/ngx_http_request.c",
        description="Vulnerability site: src/http/ngx_http_request.c on line 4211\nVulnerability type: Integer Overflow\nQualifier: ([-inf, +inf] + [-inf, +inf]):signed64",
        code='4179 static ngx_int_t\n4180 ngx_http_trace_handler(ngx_http_request_t *r)\n4181 {\n4182     ngx_list_part_t *part;\n4183     ngx_table_elt_t *header;\n4184     ngx_buf_t *b;\n4185     ngx_chain_t out;\n4186     ngx_int_t rc, content_len;\n4187 \n4188     b = ngx_create_temp_buf(r->pool, 200);\n4189     if (b == NULL) {\n4190         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n4191     }\n4192 \n4193     b->last = ngx_copy(b->last, r->request_line.data, r->request_line.len);\n4194     *b->last++ = \'\\n\';\n4195 \n4196     content_len = r->request_line.len + 1;\n4197 \n4198     part = &r->headers_in.headers.part;\n4199     header = part->elts;\n4200     for (ngx_uint_t i = 0; ; i++) {\n4201         if (i >= part->nelts) {\n4202             if (part->next == NULL) {\n4203                 b->last_buf = 1;\n4204                 break;\n4205             }\n4206             part = part->next;\n4207             header = part->elts;\n4208             i = 0;\n4209         }\n4210 \n4211         size_t header_len = header[i].key.len + header[i].value.len + 3;\n4212         content_len += header_len;\n4213 \n4214         b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);\n4215         *b->last++ = \':\';\n4216         *b->last++ = \' \';\n4217         b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len);\n4218         *b->last++ = \'\\n\';\n4219     }\n4220 \n4221     ngx_str_t ct = ngx_string("message/http");\n4222     r->headers_out.status = NGX_HTTP_OK;\n4223     r->headers_out.content_type = ct;\n4224     r->headers_out.content_length_n = content_len;\n4225     rc = ngx_http_send_header(r);\n4226 \n4227     if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n4228         return rc;\n4229     }\n4230 \n4231     out.buf = b;\n4232     out.next = NULL;\n4233 \n4234     rc = ngx_http_output_filter(r, &out);\n4235     ngx_http_close_request(r, rc);\n4236 \n4237     return NGX_DONE;\n4238 }',
    ),
    VulnTest(
        project_name="nginx-asc",
        function="ngx_http_index_handler",
        file="nginx/src/http/modules/ngx_http_index_module.c",
        description="Vulnerability site: src/http/modules/ngx_http_index_module.c on line 217\nVulnerability type: Buffer Overrun\nQualifier: Accessed Offset: [1, +inf] Buffer Size: [0, +inf] by call to `ngx_open_cached_file`\nNote: ngx_open_cached_file safety requirements : The function is unsafe unless: 1) name->len accurately represents the length of name->data and does not exceed the available memory for allocation, 2) name->data is a valid pointer to a properly null-terminated string, 3) the pool parameter is valid and has sufficient memory available for allocations",
        code=' 96 static ngx_int_t\n 97 ngx_http_index_handler(ngx_http_request_t *r)\n 98 {\n 99     u_char                       *p, *name;\n100     size_t                        len, root, reserve, allocated;\n101     ngx_int_t                     rc;\n102     ngx_str_t                     path, uri;\n103     ngx_uint_t                    i, dir_tested;\n104     ngx_http_index_t             *index;\n105     ngx_open_file_info_t          of;\n106     ngx_http_script_code_pt       code;\n107     ngx_http_script_engine_t      e;\n108     ngx_http_core_loc_conf_t     *clcf;\n109     ngx_http_index_loc_conf_t    *ilcf;\n110     ngx_http_script_len_code_pt   lcode;\n111 \n112     if (r->uri.data[r->uri.len - 1] != \'/\') {\n113         return NGX_DECLINED;\n114     }\n115 \n116     if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {\n117         return NGX_DECLINED;\n118     }\n119 \n120     ilcf = ngx_http_get_module_loc_conf(r, ngx_http_index_module);\n121     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n122 \n123     allocated = 0;\n124     root = 0;\n125     dir_tested = 0;\n126     name = NULL;\n127     /* suppress MSVC warning */\n128     path.data = NULL;\n129 \n130     index = ilcf->indices->elts;\n131     for (i = 0; i < ilcf->indices->nelts; i++) {\n132 \n133         if (index[i].lengths == NULL) {\n134 \n135             if (index[i].name.data[0] == \'/\') {\n136                 return ngx_http_internal_redirect(r, &index[i].name, &r->args);\n137             }\n138 \n139             reserve = ilcf->max_index_len;\n140             len = index[i].name.len;\n141 \n142         } else {\n143             ngx_memzero(&e, sizeof(ngx_http_script_engine_t));\n144 \n145             e.ip = index[i].lengths->elts;\n146             e.request = r;\n147             e.flushed = 1;\n148 \n149             /* 1 is for terminating \'\\0\' as in static names */\n150             len = 1;\n151 \n152             while (*(uintptr_t *) e.ip) {\n153                 lcode = *(ngx_http_script_len_code_pt *) e.ip;\n154                 len += lcode(&e);\n155             }\n156 \n157             /* 16 bytes are preallocation */\n158 \n159             reserve = len + 16;\n160         }\n161 \n162         if (reserve > allocated) {\n163 \n164             name = ngx_http_map_uri_to_path(r, &path, &root, reserve);\n165             if (name == NULL) {\n166                 return NGX_HTTP_INTERNAL_SERVER_ERROR;\n167             }\n168 \n169             allocated = path.data + path.len - name;\n170         }\n171 \n172         if (index[i].values == NULL) {\n173 \n174             /* index[i].name.len includes the terminating \'\\0\' */\n175 \n176             ngx_memcpy(name, index[i].name.data, index[i].name.len);\n177 \n178             path.len = (name + index[i].name.len - 1) - path.data;\n179 \n180         } else {\n181             e.ip = index[i].values->elts;\n182             e.pos = name;\n183 \n184             while (*(uintptr_t *) e.ip) {\n185                 code = *(ngx_http_script_code_pt *) e.ip;\n186                 code((ngx_http_script_engine_t *) &e);\n187             }\n188 \n189             if (*name == \'/\') {\n190                 uri.len = len - 1;\n191                 uri.data = name;\n192                 return ngx_http_internal_redirect(r, &uri, &r->args);\n193             }\n194 \n195             path.len = e.pos - path.data;\n196 \n197             *e.pos = \'\\0\';\n198         }\n199 \n200         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n201                        "open index \\"%V\\"", &path);\n202 \n203         ngx_memzero(&of, sizeof(ngx_open_file_info_t));\n204 \n205         of.read_ahead = clcf->read_ahead;\n206         of.directio = clcf->directio;\n207         of.valid = clcf->open_file_cache_valid;\n208         of.min_uses = clcf->open_file_cache_min_uses;\n209         of.test_only = 1;\n210         of.errors = clcf->open_file_cache_errors;\n211         of.events = clcf->open_file_cache_events;\n212 \n213         if (ngx_http_set_disable_symlinks(r, clcf, &path, &of) != NGX_OK) {\n214             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n215         }\n216 \n217         if (ngx_open_cached_file(clcf->open_file_cache, &path, &of, r->pool)\n218             != NGX_OK)\n219         {\n220             if (of.err == 0) {\n221                 return NGX_HTTP_INTERNAL_SERVER_ERROR;\n222             }\n223 \n224             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, of.err,\n225                            "%s \\"%s\\" failed", of.failed, path.data);\n226 \n227 #if (NGX_HAVE_OPENAT)\n228             if (of.err == NGX_EMLINK\n229                 || of.err == NGX_ELOOP)\n230             {\n231                 return NGX_HTTP_FORBIDDEN;\n232             }\n233 #endif\n234 \n235             if (of.err == NGX_ENOTDIR\n236                 || of.err == NGX_ENAMETOOLONG\n237                 || of.err == NGX_EACCES)\n238             {\n239                 return ngx_http_index_error(r, clcf, path.data, of.err);\n240             }\n241 \n242             if (!dir_tested) {\n243                 rc = ngx_http_index_test_dir(r, clcf, path.data, name - 1);\n244 \n245                 if (rc != NGX_OK) {\n246                     return rc;\n247                 }\n248 \n249                 dir_tested = 1;\n250             }\n251 \n252             if (of.err == NGX_ENOENT) {\n253                 continue;\n254             }\n255 \n256             ngx_log_error(NGX_LOG_CRIT, r->connection->log, of.err,\n257                           "%s \\"%s\\" failed", of.failed, path.data);\n258 \n259             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n260         }\n261 \n262         uri.len = r->uri.len + len - 1;\n263 \n264         if (!clcf->alias) {\n265             uri.data = path.data + root;\n266 \n267         } else {\n268             uri.data = ngx_pnalloc(r->pool, uri.len);\n269             if (uri.data == NULL) {\n270                 return NGX_HTTP_INTERNAL_SERVER_ERROR;\n271             }\n272 \n273             p = ngx_copy(uri.data, r->uri.data, r->uri.len);\n274             ngx_memcpy(p, name, len - 1);\n275         }\n276 \n277         return ngx_http_internal_redirect(r, &uri, &r->args);\n278     }\n279 \n280     return NGX_DECLINED;\n281 }',
    ),
    VulnTest(
        project_name="tomcat-theori",
        function="run",
        file="tomcat/java/org/apache/catalina/servlets/CGIServlet.java",
        description="Vulnerability site: java/org/apache/catalina/servlets/CGIServlet.java on line 1473\nVulnerability type: Command Injection\nQualifier: Runtime.exec could lead to command injection",
        code='1429         protected void run() throws IOException {\n1430 \n1431             /*\n1432              * REMIND: this method feels too big; should it be re-written?\n1433              */\n1434 \n1435             if (!isReady()) {\n1436                 throw new IOException(sm.getString("cgiServlet.notReady"));\n1437             }\n1438 \n1439             if (log.isTraceEnabled()) {\n1440                 log.trace("envp: [" + env + "], command: [" + command + "]");\n1441             }\n1442 \n1443             if ((command.contains(File.separator + "." + File.separator)) ||\n1444                     (command.contains(File.separator + "..")) || (command.contains(".." + File.separator))) {\n1445                 throw new IOException(sm.getString("cgiServlet.invalidCommand", command));\n1446             }\n1447 \n1448             /*\n1449              * original content/structure of this section taken from\n1450              * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4216884 with major modifications by Martin Dengler\n1451              */\n1452             Runtime rt = null;\n1453             BufferedReader cgiHeaderReader = null;\n1454             InputStream cgiOutput = null;\n1455             BufferedReader commandsStdErr = null;\n1456             Thread errReaderThread = null;\n1457             BufferedOutputStream commandsStdIn = null;\n1458             Process proc = null;\n1459             int bufRead = -1;\n1460 \n1461             List<String> cmdAndArgs = new ArrayList<>();\n1462             if (cgiExecutable.length() != 0) {\n1463                 cmdAndArgs.add(cgiExecutable);\n1464             }\n1465             if (cgiExecutableArgs != null) {\n1466                 cmdAndArgs.addAll(cgiExecutableArgs);\n1467             }\n1468             cmdAndArgs.add(command);\n1469             cmdAndArgs.addAll(params);\n1470 \n1471             try {\n1472                 rt = Runtime.getRuntime();\n1473                 proc = rt.exec(cmdAndArgs.toArray(new String[0]), mapToStringArray(env), wd);\n1474 \n1475                 String sContentLength = env.get("CONTENT_LENGTH");\n1476 \n1477                 if (!"".equals(sContentLength)) {\n1478                     commandsStdIn = new BufferedOutputStream(proc.getOutputStream());\n1479                     IOTools.flow(stdin, commandsStdIn);\n1480                     commandsStdIn.flush();\n1481                     commandsStdIn.close();\n1482                 }\n1483 \n1484                 /*\n1485                  * we want to wait for the process to exit, Process.waitFor() is useless in our situation; see\n1486                  * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4223650\n1487                  */\n1488 \n1489                 boolean isRunning = true;\n1490                 commandsStdErr = new BufferedReader(new InputStreamReader(proc.getErrorStream()));\n1491                 final BufferedReader stdErrRdr = commandsStdErr;\n1492 \n1493                 errReaderThread = new Thread(() -> sendToLog(stdErrRdr));\n1494                 errReaderThread.start();\n1495 \n1496                 InputStream cgiHeaderStream = new HTTPHeaderInputStream(proc.getInputStream());\n1497                 cgiHeaderReader = new BufferedReader(new InputStreamReader(cgiHeaderStream));\n1498 \n1499                 // Need to be careful here. If sendError() is called the\n1500                 // response body should be provided by the standard error page\n1501                 // process. But, if the output of the CGI process isn\'t read\n1502                 // then that process can hang.\n1503                 boolean skipBody = false;\n1504 \n1505                 while (isRunning) {\n1506                     try {\n1507                         // set headers\n1508                         String line = null;\n1509                         while (((line = cgiHeaderReader.readLine()) != null) && !line.isEmpty()) {\n1510                             if (log.isTraceEnabled()) {\n1511                                 log.trace("addHeader(\\"" + line + "\\")");\n1512                             }\n1513                             if (line.startsWith("HTTP")) {\n1514                                 skipBody = setStatus(response, getSCFromHttpStatusLine(line));\n1515                             } else if (line.indexOf(\':\') >= 0) {\n1516                                 String header = line.substring(0, line.indexOf(\':\')).trim();\n1517                                 String value = line.substring(line.indexOf(\':\') + 1).trim();\n1518                                 if (header.equalsIgnoreCase("status")) {\n1519                                     skipBody = setStatus(response, getSCFromCGIStatusHeader(value));\n1520                                 } else {\n1521                                     response.addHeader(header, value);\n1522                                 }\n1523                             } else {\n1524                                 log.info(sm.getString("cgiServlet.runBadHeader", line));\n1525                             }\n1526                         }\n1527 \n1528                         // write output\n1529                         byte[] bBuf = new byte[2048];\n1530 \n1531                         OutputStream out = response.getOutputStream();\n1532                         cgiOutput = proc.getInputStream();\n1533 \n1534                         try {\n1535                             while (!skipBody && (bufRead = cgiOutput.read(bBuf)) != -1) {\n1536                                 if (log.isTraceEnabled()) {\n1537                                     log.trace("output " + bufRead + " bytes of data");\n1538                                 }\n1539                                 out.write(bBuf, 0, bufRead);\n1540                             }\n1541                         } finally {\n1542                             // Attempt to consume any leftover byte if something bad happens,\n1543                             // such as a socket disconnect on the servlet side; otherwise, the\n1544                             // external process could hang\n1545                             if (bufRead != -1) {\n1546                                 while ((bufRead = cgiOutput.read(bBuf)) != -1) {\n1547                                     // NOOP - just read the data\n1548                                 }\n1549                             }\n1550                         }\n1551 \n1552                         proc.exitValue(); // Throws exception if alive\n1553 \n1554                         isRunning = false;\n1555 \n1556                     } catch (IllegalThreadStateException e) {\n1557                         try {\n1558                             Thread.sleep(500);\n1559                         } catch (InterruptedException ignored) {\n1560                             // Ignore\n1561                         }\n1562                     }\n1563                 } // replacement for Process.waitFor()\n1564 \n1565             } catch (IOException e) {\n1566                 log.warn(sm.getString("cgiServlet.runFail"), e);\n1567                 throw e;\n1568             } finally {\n1569                 // Close the header reader\n1570                 if (cgiHeaderReader != null) {\n1571                     try {\n1572                         cgiHeaderReader.close();\n1573                     } catch (IOException ioe) {\n1574                         log.warn(sm.getString("cgiServlet.runHeaderReaderFail"), ioe);\n1575                     }\n1576                 }\n1577                 // Close the output stream if used\n1578                 if (cgiOutput != null) {\n1579                     try {\n1580                         cgiOutput.close();\n1581                     } catch (IOException ioe) {\n1582                         log.warn(sm.getString("cgiServlet.runOutputStreamFail"), ioe);\n1583                     }\n1584                 }\n1585                 // Make sure the error stream reader has finished\n1586                 if (errReaderThread != null) {\n1587                     try {\n1588                         errReaderThread.join(stderrTimeout);\n1589                     } catch (InterruptedException e) {\n1590                         log.warn(sm.getString("cgiServlet.runReaderInterrupt"));\n1591                     }\n1592                 }\n1593                 if (proc != null) {\n1594                     proc.destroy();\n1595                     proc = null;\n1596                 }\n1597             }\n1598         }',
    ),
    VulnTest(
        project_name="example-libpng-theori",
        function="png_handle_cICP",
        file="libpng/pngrutil.c",
        description="Vulnerability site: pngrutil.c on line 2082\nVulnerability type: Buffer Overrun\nQualifier: Accessed Offset [0, 3] Buffer Size: [0, +inf] by call to `png_crc_read` on line 2082\nNote: png_crc_read safety requirements : buffer size must be at least read size",
        code='2051 void /* PRIVATE */\n2052 png_handle_cICP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n2053 {\n2054    png_byte buf[4];\n2055 \n2056    png_debug(1, "in png_handle_cICP");\n2057 \n2058    if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n2059       png_chunk_error(png_ptr, "missing IHDR");\n2060 \n2061    else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n2062    {\n2063       png_crc_finish(png_ptr, length);\n2064       png_chunk_benign_error(png_ptr, "out of place");\n2065       return;\n2066    }\n2067 \n2068    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cICP) != 0)\n2069    {\n2070       png_crc_finish(png_ptr, length);\n2071       png_chunk_benign_error(png_ptr, "duplicate");\n2072       return;\n2073    }\n2074 \n2075    else if (length != 4)\n2076    {\n2077       png_crc_finish(png_ptr, length);\n2078       png_chunk_benign_error(png_ptr, "invalid");\n2079       return;\n2080    }\n2081 \n2082    png_crc_read(png_ptr, buf, 4);\n2083 \n2084    if (png_crc_finish(png_ptr, 0) != 0)\n2085       return;\n2086 \n2087    png_set_cICP(png_ptr, info_ptr, buf[0], buf[1],  buf[2], buf[3]);\n2088 }',
    ),
]

async def run_analyzer(project: TestProject, testcase: VulnTest):
    if "infinite loop" in testcase.description.lower():
        pytest.skip("vuln_analyzer is known to fail on infinite loops because of our prompting, see #233")
    task = (await project.tasks()).unwrap()[-1]
    res = await CRSVuln.from_task(task).analyze_vuln_report(testcase)
    return res.unwrap()

@pytest.mark.slow
async def test_vuln_analyzer(best_models: None, project: TestProject):
    pos = [t for t in positives if t.project_name == project.name]
    neg = [t for t in negatives if t.project_name == project.name]
    analyses = await asyncio.gather(*[run_analyzer(project, t) for t in pos])
    for t, analysis in zip(pos, analyses):
        assert analysis.triggerable, f"analyzer rejected positive vuln: {t}"
    analyses = await asyncio.gather(*[run_analyzer(project, t) for t in neg])
    for t, analysis in zip(neg, analyses):
        assert not analysis.triggerable, f"analyzer accepted false positive vuln: {t}"